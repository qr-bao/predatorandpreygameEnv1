# File: /home/qrbao/Downloads/code/code/coderesearch1/creature.py
# creature.py
import pygame
import random
import math
import constants
from abc import ABC, abstractmethod

class Creature(ABC):
    def __init__(self, x, y, size, color, initial_health, max_health, health_decay, hearing_range):
        self.rect = pygame.Rect(x, y, size, size)
        self.color = color
        self.original_color = color  # 保存原始颜色
        angle = random.uniform(0, 2 * math.pi)
        self.velocity = [math.cos(angle), math.sin(angle)]
        self.previous_velocity = self.velocity[:]  # 新增的
        self.health = initial_health
        self.max_health = max_health
        self.health_decay = health_decay
        self.sight_range = 200  # 初始值
        self.sight_angle = math.pi / 3  # 可视角度
        self.hearing_range = hearing_range  # 听觉范围
        self.selected = False  # 新增的
        self.iteration_counter = 0  # 新增的迭代计数器
    
    def increment_iteration(self):
        self.iteration_counter += 1
    
    def draw_sight_range(self, screen):
        end_x = self.rect.centerx + self.sight_range * math.cos(math.atan2(self.velocity[1], self.velocity[0]))
        end_y = self.rect.centery + self.sight_range * math.sin(math.atan2(self.velocity[1], self.velocity[0]))
        pygame.draw.line(screen, (255, 255, 0), self.rect.center, (end_x, end_y), 1)  # 画出视觉范围线
        pygame.draw.arc(screen, (255, 255, 0), (self.rect.centerx - self.sight_range, self.rect.centery - self.sight_range, 2 * self.sight_range, 2 * self.sight_range), 
                        math.atan2(self.velocity[1], self.velocity[0]) - self.sight_angle / 2, 
                        math.atan2(self.velocity[1], self.velocity[0]) + self.sight_angle / 2, 1)  # 画出视觉范围弧线

    def draw_hearing_range(self, screen):
        pygame.draw.circle(screen, (128, 128, 128), self.rect.center, self.hearing_range, 1)  # 画出听觉范围

    def highlight_targets(self, screen, observed_predator, observed_prey, observed_food, observed_obstacle):
        if observed_predator:
            observed_predator.color = (255, 255, 0)  # 高亮捕食者
        if observed_prey:
            observed_prey.color = (0, 0, 255)  # 高亮猎物
        if observed_food:
            observed_food.color = (255, 0, 0)  # 高亮食物
        if observed_obstacle:
            pygame.draw.rect(screen, (255, 255, 255), observed_obstacle.rect, 2)  # 高亮障碍物框架

    def reset_color(self):
        self.color = self.original_color  # 重置颜色

    @classmethod
    def reset_all_colors(cls, creatures):
        for creature in creatures:
            creature.reset_color()

    def move(self, control_panel_width, screen_width, screen_height, obstacles):
        # 保存原始位置
        original_position = self.rect.topleft

        # 子类具体实现移动策略
        self.move_strategy()

        # 碰撞检测，防止小方块移出游戏空间
        if self.rect.left < control_panel_width or self.rect.right > screen_width:
            self.velocity[0] = -self.velocity[0]
        if self.rect.top < 0 or self.rect.bottom > screen_height:
            self.velocity[1] = -self.velocity[1]

        # 检查是否与障碍物碰撞
        if any(self.rect.colliderect(obs.rect) for obs in obstacles):
            # 如果碰撞，恢复到原始位置并反转速度
            self.rect.topleft = original_position
            self.velocity[0] = -self.velocity[0]
            self.velocity[1] = -self.velocity[1]

    def observe_info(self, env_predators, env_prey, env_food, env_obstacles):
        def is_in_sight(target):
            dx = target.rect.centerx - self.rect.centerx
            dy = target.rect.centery - self.rect.centery
            distance = math.sqrt(dx**2 + dy**2)
            angle_to_target = math.atan2(dy, dx)
            relative_angle = angle_to_target - math.atan2(self.velocity[1], self.velocity[0])
            relative_angle = (relative_angle + math.pi) % (2 * math.pi) - math.pi  # 将角度限制在 [-pi, pi]
            return (distance <= self.sight_range) and (abs(relative_angle) <= self.sight_angle / 2)

        def is_occluded(target, obstacles):
            for obstacle in obstacles:
                if self.rect.colliderect(obstacle.rect):
                    continue
                if self.line_intersects_rect((self.rect.centerx, self.rect.centery), (target.rect.centerx, target.rect.centery), obstacle.rect):
                    return True
            return False

        def find_first_visible(targets, obstacles):
            visible_targets = sorted(targets, key=lambda t: self.distance_to(t))
            for target in visible_targets:
                if is_in_sight(target) and not is_occluded(target, obstacles):
                    return target
            return None

        def is_in_hearing_range(target):
            dx = target.rect.centerx - self.rect.centerx
            dy = target.rect.centery - self.rect.centery
            distance = math.sqrt(dx**2 + dy**2)
            return distance <= self.hearing_range

        def get_sound_intensity(target):
            dx = target.rect.centerx - self.rect.centerx
            dy = target.rect.centery - self.rect.centery
            distance = math.sqrt(dx**2 + dy**2)
            return max(0, (self.hearing_range - distance) / self.hearing_range)

        def get_sound_direction(target):
            dx = target.rect.centerx - self.rect.centerx
            dy = target.rect.centery - self.rect.centery
            angle_to_target = math.atan2(dy, dx)
            relative_angle = angle_to_target - math.atan2(self.velocity[1], self.velocity[0])
            relative_angle = (relative_angle + math.pi) % (2 * math.pi) - math.pi  # 将角度限制在 [-pi, pi]
            return relative_angle

        # 视觉感知
        observed_predator = find_first_visible(env_predators, env_obstacles)
        observed_prey = find_first_visible(env_prey, env_obstacles)
        observed_food = find_first_visible(env_food, env_obstacles)
        observed_obstacle = find_first_visible(env_obstacles, env_obstacles)

        # 听觉感知
        heard_entities = [entity for entity in env_predators + env_prey if is_in_hearing_range(entity)]
        heard_sounds = [(get_sound_intensity(entity), get_sound_direction(entity)) for entity in heard_entities]

        return observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds

    def distance_to(self, other):
        dx = other.rect.centerx - self.rect.centerx
        dy = other.rect.centery - self.rect.centery
        return (dx ** 2 + dy ** 2) ** 0.5

    def line_intersects_rect(self, p1, p2, rect):
        lines = [
            ((rect.left, rect.top), (rect.right, rect.top)),
            ((rect.right, rect.top), (rect.right, rect.bottom)),
            ((rect.right, rect.bottom), (rect.left, rect.bottom)),
            ((rect.left, rect.bottom), (rect.left, rect.top))
        ]
        for line in lines:
            if self.lines_intersect(p1, p2, line[0], line[1]):
                return True
        return False

    def lines_intersect(self, p1, p2, p3, p4):
        def ccw(A, B, C):
            return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

        return ccw(p1, p3, p4) != ccw(p2, p3, p4) and ccw(p1, p2, p3) != ccw(p1, p2, p4)

    @abstractmethod
    def move_strategy(self):
        pass

    @abstractmethod
    def get_target(self, observed_predator, observed_prey, observed_food, observed_obstacle):
        pass

    def update_health(self):
        self.health -= self.health_decay
        if self.health <= 0:
            self.health = 0
        elif self.health > self.max_health:
            self.health = self.max_health

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect)

    def is_dead(self):
        return self.health <= 0


# File: /home/qrbao/Downloads/code/code/coderesearch1/predator.py
import math
from creature import Creature
import constants
import random
class Predator(Creature):
    def __init__(self, x, y, size):
        super().__init__(x, y, size, (255, 0, 0), constants.PREDATOR_INITIAL_HEALTH, constants.PREDATOR_MAX_HEALTH, constants.PREDATOR_HEALTH_DECAY, constants.PREDATOR_HEARING_RANGE)
        self.sight_range = constants.PREDATOR_SIGHT_RANGE  # 使用新的视觉范围
        self.prey_list = []

    def draw(self, screen):
        self.reset_color()  # 重置颜色
        super().draw(screen)
        if self.selected:  # 如果被选中，显示视觉和听觉范围
            self.draw_sight_range(screen)
            self.draw_hearing_range(screen)
            observed_predator, observed_prey, observed_food, observed_obstacle, _ = self.observe_info(self.env_predators, self.env_prey, self.env_food, self.env_obstacles)
            self.highlight_targets(screen, observed_predator, observed_prey, observed_food, observed_obstacle)

    def set_prey_list(self, prey_list):
        self.prey_list = prey_list

    def move_strategy(self):
        Creature.reset_all_colors(self.env_predators + self.env_prey)
        observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds = self.observe_info(self.env_predators, self.env_prey, self.env_food, self.env_obstacles)
        move_vector = self.get_target(observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds)

        # 更新速度部分
        self.previous_velocity = self.velocity[:]
        self.velocity[0] += move_vector[0]  # 更新 x 方向的速度
        self.velocity[1] += move_vector[1]  # 更新 y 方向的速度

        # 限制速度
        speed = math.sqrt(self.velocity[0] ** 2 + self.velocity[1] ** 2)
        if speed > constants.PREDATOR_MAX_SPEED:
            self.velocity[0] = (self.velocity[0] / speed) * constants.PREDATOR_MAX_SPEED
            self.velocity[1] = (self.velocity[1] / speed) * constants.PREDATOR_MAX_SPEED

        # 避免速度归零
        if self.velocity[0] == 0 and self.velocity[1] == 0:
            self.velocity = [random.choice([-1, 1]), random.choice([-1, 1])]

        # 移动 Predator
        self.rect.x += self.velocity[0]
        self.rect.y += self.velocity[1]

    def get_target(self, observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds):
        move_vector = [0, 0]

        if observed_prey:
            # 靠近猎物并加速
            dx = observed_prey.rect.x - self.rect.x
            dy = observed_prey.rect.y - self.rect.y
            dist = self.distance_to(observed_prey)
            
            if dist > 0:  # 检查距离是否为零
                move_vector[0] += (dx / dist) * constants.PREDATOR_ACCELERATION_FACTOR
                move_vector[1] += (dy / dist) * constants.PREDATOR_ACCELERATION_FACTOR

        elif observed_food:
            # 靠近食物
            dx = observed_food.rect.x - self.rect.x
            dy = observed_food.rect.y - self.rect.y
            dist = self.distance_to(observed_food)
            if dist > 0:  # 检查距离是否为零
                move_vector[0] += dx / dist
                move_vector[1] += dy / dist
        
        else:
            # 停下来并旋转观察周围
            if random.random() < constants.PREDATOR_ROTATION_CHANCE:
                angle = random.uniform(-math.pi, math.pi)
                self.velocity[0] = math.cos(angle) * constants.PREDATOR_ROTATION_SPEED
                self.velocity[1] = math.sin(angle) * constants.PREDATOR_ROTATION_SPEED
            else:
                move_vector[0] = 0
                move_vector[1] = 0

        # 利用听觉信息来影响移动策略
        for sound_intensity, sound_direction in heard_sounds:
            move_vector[0] += sound_intensity * math.cos(sound_direction)
            move_vector[1] += sound_intensity * math.sin(sound_direction)

        return move_vector

    def hunt_prey(self, prey_list):
        for prey in prey_list:
            if self.rect.colliderect(prey.rect):
                self.health += prey.health * constants.PREDATOR_HEALTH_GAIN_FACTOR
                if self.health > self.max_health:
                    self.health = self.max_health
                prey.health = 0  # 猎物死亡
                prey_list.remove(prey)
                return

    def crossbreed(self, other):
        child_x = (self.rect.x + other.rect.x) // 2
        child_y = (self.rect.y + other.rect.y) // 2
        child_size = constants.BLOCK_SIZE
        child = Predator(child_x, child_y, child_size)
        return child

    def mutate(self):
        self.velocity[0] = random.choice([-1, 1])
        self.velocity[1] = random.choice([-1, 1])

    def update_health(self):
        # 基础的健康值减少
        health_decay = self.health_decay * 2  # 将捕食者的生命值减少速度设置为猎物的两倍

        # 根据速度变化计算加速度
        accel_x = self.velocity[0] - self.previous_velocity[0]
        accel_y = self.velocity[1] - self.previous_velocity[1]
        acceleration = math.sqrt(accel_x ** 2 + accel_y ** 2)
        
        # 根据加速度计算额外的健康值减少
        health_decay += acceleration * constants.PREDATOR_ACCELERATION_HEALTH_DECAY_FACTOR

        self.health -= health_decay

        if self.health <= 0:
            self.health = 0
        elif self.health > self.max_health:
            self.health = self.max_health


# File: /home/qrbao/Downloads/code/code/coderesearch1/main.py
# main.py
import pygame
import random
import matplotlib.pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from simulator import Simulator
import constants

pygame.init()

# 设置全屏窗口
screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
pygame.display.set_caption("Control Panel and Game Space")

# 获取屏幕尺寸
screen_width, screen_height = screen.get_size()
#print(screen_width)
#print(screen_height)

# 字体设置
font = pygame.font.Font(None, constants.FONT_SIZE)

# 侧边栏宽度
sidebar_width = constants.CONTROL_PANEL_WIDTH

# 按钮配置
buttons = [
    pygame.Rect(50, 100, constants.BUTTON_WIDTH, constants.BUTTON_HEIGHT),
    pygame.Rect(50, 100 + (constants.BUTTON_HEIGHT + constants.BUTTON_MARGIN), constants.BUTTON_WIDTH, constants.BUTTON_HEIGHT),
    pygame.Rect(50, 100 + 2 * (constants.BUTTON_HEIGHT + constants.BUTTON_MARGIN), constants.BUTTON_WIDTH, constants.BUTTON_HEIGHT)
]

slow_button = pygame.Rect(50, 100 + 3 * (constants.BUTTON_HEIGHT + constants.BUTTON_MARGIN), constants.BUTTON_WIDTH, constants.BUTTON_HEIGHT)

# 定义游戏状态
game_state = constants.MAIN_MENU

# 初始化模拟器
sim = Simulator(screen_width, screen_height)

# 初始化帧率
fps = constants.DEFAULT_FPS
clock = pygame.time.Clock()

# 迭代计数器
iteration_count = 0

# 初始化数据记录结构
prey_counts = []
predator_counts = []
prey_born_count = 0
predator_born_count = 0

# 创建图表
fig, ax = plt.subplots(figsize=(3, 2))  # 设置图表尺寸适应侧边栏
canvas = FigureCanvas(fig)

def update_plot(prey_counts, predator_counts):
    ax.clear()
    ax.plot(prey_counts, label="Prey", color='blue')
    ax.plot(predator_counts, label="Predator", color='red')
    ax.legend(loc='upper right')
    ax.set_title("Population Over Time")
    canvas.draw()

def blit_plot():
    raw_data = canvas.tostring_rgb()
    size = canvas.get_width_height()
    plot_surface = pygame.image.fromstring(raw_data, size, "RGB")
    return plot_surface

# 游戏主循环
running = True
selected_agent = None

while running:
    delta_time = clock.get_time() / 1000.0  # 计算帧时间，单位为秒
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if game_state == constants.MAIN_MENU:
                for button in buttons:
                    if button.collidepoint(event.pos):
                        if buttons.index(button) == 0:
                            game_state = constants.IN_GAME
                            sim.initialize()
                            print("Game Started")
            elif game_state == constants.IN_GAME:
                if slow_button.collidepoint(event.pos):
                    fps = constants.SLOW_FPS if fps == constants.DEFAULT_FPS else constants.DEFAULT_FPS
                else:
                    selected_agent = sim.get_agent_info(event.pos)
                    if selected_agent:
                        selected_agent.selected = True
                        for agent in sim.predators + sim.prey:
                            if agent != selected_agent:
                                agent.selected = False
                    else:
                        for agent in sim.predators + sim.prey:
                            agent.selected = False

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                if game_state == constants.IN_GAME:
                    game_state = constants.MAIN_MENU
                    selected_agent = None
                    for agent in sim.predators + sim.prey:
                        agent.selected = False

    screen.fill((0,0, 0))

    # 绘制侧边栏背景
    pygame.draw.rect(screen, (50, 50, 50), (0, 0, sidebar_width, screen_height))

    if game_state == constants.MAIN_MENU:
        for button in buttons:
            color = constants.BUTTON_HOVER_COLOR if button.collidepoint(pygame.mouse.get_pos()) else constants.BUTTON_COLOR
            pygame.draw.rect(screen, color, button)
            text = font.render(constants.BUTTON_TEXTS[buttons.index(button)], True, (255, 255, 255))
            screen.blit(text, (button.x + (constants.BUTTON_WIDTH - text.get_width()) // 2, button.y + (constants.BUTTON_HEIGHT - text.get_height()) // 2))

    elif game_state == constants.IN_GAME:
        sim.check_events()
        sim.add_food()  # 传递时间间隔
        sim.move_models()
        sim.prey_hunt()
        sim.predator_hunt()
        sim.decrease_health()  # 更新健康值
        sim.remove_dead()  # 清理死亡个体
        iteration_count += 1  # 增加迭代计数器
        sim.draw_models(screen)

        # 每100个回合输出日志
        if iteration_count % 10 == 0:
            new_prey_born, new_predator_born = sim.applyGeneticAlgorithm()
            # prey_born_count += new_prey_born
            # predator_born_count += new_predator_born
            # print(f"Iteration {iteration_count}: Current Predators: {len(sim.predators)}, New Predators Born: {predator_born_count}, Predators Died: {sim.dead_predator_count}")
            # prey_born_count = 0
            # predator_born_count = 0
            # sim.dead_predator_count = 0  # 重置死亡捕食者计数

        # 更新数据记录结构
        prey_counts.append(len(sim.prey))
        predator_counts.append(len(sim.predators))

        # 更新并绘制图表
        update_plot(prey_counts, predator_counts)
        plot_surface = blit_plot()
        plot_rect = plot_surface.get_rect(center=(sidebar_width // 2, screen_height // 2))
        screen.blit(plot_surface, plot_rect.topleft)

        color = constants.BUTTON_HOVER_COLOR if slow_button.collidepoint(pygame.mouse.get_pos()) else constants.BUTTON_COLOR
        pygame.draw.rect(screen, color, slow_button)
        text = font.render("Slow Down", True, (255, 255, 255))
        screen.blit(text, (slow_button.x + (constants.BUTTON_WIDTH - text.get_width()) // 2, slow_button.y + (constants.BUTTON_HEIGHT - text.get_height()) // 2))

        # 显示迭代次数
        iteration_text = font.render(f"Iteration: {iteration_count}", True, (255, 255, 255))
        screen.blit(iteration_text, (50, screen_height - 150))

        if selected_agent:
            agent_info = (
                f"{selected_agent.__class__.__name__}: "
                f"Position ({selected_agent.rect.x}, {selected_agent.rect.y}), "
                f"Velocity ({selected_agent.velocity[0]}, {selected_agent.velocity[1]}), "
                f"Health ({selected_agent.health})"
            )
            info_surface = font.render(agent_info, True, (255, 255, 255))
            screen.blit(info_surface, (50, screen_height - 100))

    pygame.display.flip()
    clock.tick(fps)

pygame.quit()


# File: /home/qrbao/Downloads/code/code/coderesearch1/constants.py
# constants.py

# 窗口设置
SCREEN_WIDTH = 1600
SCREEN_HEIGHT = 900

SCREEN_WIDTH1 = 3840
SCREEN_HEIGHT1 = 2160
# 控制栏和游戏空间宽度
CONTROL_PANEL_WIDTH = 400

# 按钮属性
BUTTON_COLOR = (0, 255, 0)
BUTTON_HOVER_COLOR = (255, 0, 0)
BUTTON_WIDTH = 150
BUTTON_HEIGHT = 50
BUTTON_MARGIN = 20

# 字体设置
FONT_SIZE = 36
BUTTON_TEXTS = ["Start Game", "Button 2", "Button 3", "Slow Down"]

# 新增常量，定义食物生成的中心75%范围
CENTER_AREA_WIDTH = int((SCREEN_WIDTH1 -CONTROL_PANEL_WIDTH)*0.75 )
CENTER_AREA_HEIGHT = int(SCREEN_HEIGHT1 * 0.75)
CENTER_AREA_X_START = int(CONTROL_PANEL_WIDTH+(SCREEN_WIDTH1-CONTROL_PANEL_WIDTH-CENTER_AREA_WIDTH)//2) 
CENTER_AREA_Y_START = int((SCREEN_HEIGHT1-CENTER_AREA_HEIGHT)//2)
# 游戏状态
MAIN_MENU = 0
IN_GAME = 1

# 小方块属性
NUM_PREDATORS = 10  # 捕食者初始数量
NUM_PREY = 30  # 猎物初始数量
BLOCK_SIZE = 40

# 捕食者和猎物的生命值和生命值衰减
PREDATOR_INITIAL_HEALTH = 45  # 增加初始健康值
PREY_INITIAL_HEALTH = 20  # 增加初始健康值
PREDATOR_HEALTH_DECAY = 0.04  # 减少健康值衰减速度
PREY_HEALTH_DECAY = 0.25  # 减少猎物的健康值衰减速度

# 捕食者和猎物的生命值上限
PREDATOR_MAX_HEALTH = 100  # 增加健康值上限
PREY_MAX_HEALTH = 50  # 增加健康值上限

# 食物属性
NUM_FOOD = 100  # 增加初始食物数量
FOOD_SIZE = 20
FOOD_COLOR = (0, 0, 255)
FOOD_HEALTH_GAIN = 6  # 增加食物提供的健康值
# FOOD_GENERATION_INTERVAL = 80  # 每5秒生成一次食物
# 新增的常量
RANDOM_FOOD_PROPORTION = 0.1  # 随机食物的比例
FOOD_GENERATION_INTERVAL = 45  # 食物生成的迭代间隔
FOOD_SPAWN_DISTANCE = 55  # 食物生成时的偏移距离
MAX_FOOD_COUNT = 400  # 食物生成的最大数量
# 捕食相关
PREDATOR_HEALTH_GAIN_FACTOR = 0.8  # 调整捕食获得的健康值

# 游戏速度
DEFAULT_FPS = 30
SLOW_FPS = 10

# 遗传算法相关
MUTATION_CHANCE = 0.01  # 增加突变几率
PREY_REPRODUCTION_PROBABILITY = 0.2
PREDATOR_REPRODUCTION_PROBABILITY = 0.5
PREDATOR_SPEED = 5

# 速度和加速度
PREY_MAX_SPEED = 17 
PREY_MAX_ACCELERATION = 2.5
PREY_MAX_TURNING_ANGLE = 0.5

PREDATOR_MAX_SPEED = 17 
PREDATOR_MAX_ACCELERATION = 4
PREDATOR_MAX_TURNING_ANGLE = 0.8

# 听觉范围
PREDATOR_HEARING_RANGE = 800
PREY_HEARING_RANGE = 800

# 健康值减少相关常量
PREDATOR_ACCELERATION_HEALTH_DECAY_FACTOR = 0.05# 减少加速导致的健康值衰减
PREY_ACCELERATION_HEALTH_DECAY_FACTOR = 0.10  # 减少加速导致的健康值衰减

# 新增的常量
PREDATOR_MIN_DISTANCE = 10  # 捕食者最小接近距离
PREDATOR_ROTATION_CHANCE = 0.05  # 减少停下来旋转的几率
PREDATOR_ROTATION_SPEED = 1  # 旋转的速度
PREDATOR_ACCELERATION_FACTOR = 9.2  # 调整捕食者加速因子

PREY_EVASION_FACTOR = 2.5  # 增强远离捕食者的因子
PREY_RANDOM_MOVE_CHANCE = 0.05  # 减少随机移动的几率
PREY_RANDOM_MOVE_SPEED = 1.5  # 随机移动的速度
PREY_TURN_INTERVAL = 50  # 增加定期回头观察的间隔（帧数）

# 视觉范围
PREDATOR_SIGHT_RANGE = 600  # 调整捕食者的视觉范围
PREY_SIGHT_RANGE = 600  # 调整猎物的视觉范围

# 最大迭代次数
MAX_ITERATIONS = 10000  # 设置为一个合理的值以控制运行时间

# 繁殖所需的最低生命值
PREDATOR_MIN_HEALTH_FOR_REPRODUCTION = PREDATOR_INITIAL_HEALTH * 2.0 
PREY_MIN_HEALTH_FOR_REPRODUCTION = PREY_INITIAL_HEALTH * 2.0

# 繁殖迭代计数器阈值
PREY_REPRODUCTION_ITERATION_THRESHOLD = 5
PREDATOR_REPRODUCTION_ITERATION_THRESHOLD = 5


# File: /home/qrbao/Downloads/code/code/coderesearch1/spawning.py
# spawning.py
import random
import pygame
from predator import Predator
from prey import Prey
from food import Food
import constants

def spawn_predator(obstacles, screen_width, screen_height):
    while True:
        x = random.randint(constants.CONTROL_PANEL_WIDTH, screen_width - constants.BLOCK_SIZE)
        y = random.randint(0, screen_height - constants.BLOCK_SIZE)
        agent_rect = pygame.Rect(x, y, constants.BLOCK_SIZE, constants.BLOCK_SIZE)
        if not any(agent_rect.colliderect(obs.rect) for obs in obstacles):
            return Predator(x, y, constants.BLOCK_SIZE)

def spawn_prey(obstacles, screen_width, screen_height):
    while True:
        x = random.randint(constants.CONTROL_PANEL_WIDTH, screen_width - constants.BLOCK_SIZE)
        y = random.randint(0, screen_height - constants.BLOCK_SIZE)
        agent_rect = pygame.Rect(x, y, constants.BLOCK_SIZE, constants.BLOCK_SIZE)
        if not any(agent_rect.colliderect(obs.rect) for obs in obstacles):
            return Prey(x, y, constants.BLOCK_SIZE)

def spawn_food(obstacles, screen_width, screen_height):
    while True:
        x = random.randint(constants.CENTER_AREA_X_START, constants.CENTER_AREA_X_START + constants.CENTER_AREA_WIDTH - constants.FOOD_SIZE)
        y = random.randint(constants.CENTER_AREA_Y_START, constants.CENTER_AREA_Y_START + constants.CENTER_AREA_HEIGHT - constants.FOOD_SIZE)
        food_rect = pygame.Rect(x, y, constants.FOOD_SIZE, constants.FOOD_SIZE)
        if not any(food_rect.colliderect(obs.rect) for obs in obstacles):
            return Food(x, y, constants.FOOD_SIZE)

# File: /home/qrbao/Downloads/code/code/coderesearch1/prey.py
# prey.py
import random
import math
from creature import Creature
import constants

class Prey(Creature):
    def __init__(self, x, y, size):
        super().__init__(x, y, size, (0, 255, 0), constants.PREY_INITIAL_HEALTH, constants.PREY_MAX_HEALTH, constants.PREY_HEALTH_DECAY, constants.PREY_HEARING_RANGE)
        self.sight_range = constants.PREY_SIGHT_RANGE  # 使用新的视觉范围
        self.turn_counter = 0  # 用于记录逃跑时的计时器

    def draw(self, screen):
        self.reset_color()  # 重置颜色
        super().draw(screen)
        if self.selected:  # 如果被选中，显示视觉和听觉范围
            self.draw_sight_range(screen)
            self.draw_hearing_range(screen)
            observed_predator, observed_prey, observed_food, observed_obstacle, _ = self.observe_info(self.env_predators, self.env_prey, self.env_food, self.env_obstacles)
            self.highlight_targets(screen, observed_predator, observed_prey, observed_food, observed_obstacle)

    def move_strategy(self):
        Creature.reset_all_colors(self.env_predators + self.env_prey)
        observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds = self.observe_info(self.env_predators, self.env_prey, self.env_food, self.env_obstacles)
        move_vector = self.get_target(observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds)

        # 更新速度部分
        self.previous_velocity = self.velocity[:]
        self.velocity[0] += move_vector[0]  # 更新 x 方向的速度
        self.velocity[1] += move_vector[1]  # 更新 y 方向的速度

        # 限制速度
        speed = math.sqrt(self.velocity[0] ** 2 + self.velocity[1] ** 2)
        if speed > constants.PREY_MAX_SPEED:
            self.velocity[0] = (self.velocity[0] / speed) * constants.PREY_MAX_SPEED
            self.velocity[1] = (self.velocity[1] / speed) * constants.PREY_MAX_SPEED

        # 避免速度归零
        if self.velocity[0] == 0 and self.velocity[1] == 0:
            self.velocity = [random.choice([-1, 1]), random.choice([-1, 1])]
        # 细化移动步骤并检测碰撞
        step_size = 5  # 可以调整步长大小
        total_steps = max(abs(self.velocity[0]), abs(self.velocity[1])) // step_size

        for step in range(int(total_steps)):
            self.rect.x += self.velocity[0] / total_steps
            self.rect.y += self.velocity[1] / total_steps
            self.eat_food(self.env_food)  # 在每一步检查碰撞
        # 移动 Prey
        self.rect.x += self.velocity[0]
        self.rect.y += self.velocity[1]

    def get_target(self, observed_predator, observed_prey, observed_food, observed_obstacle, heard_sounds):
        move_vector = [0, 0]
        avoid_vector = [0, 0]

        # 远离捕食者
        if observed_predator:
            dx = self.rect.x - observed_predator.rect.x
            dy = self.rect.y - observed_predator.rect.y
            dist = self.distance_to(observed_predator)
            if dist > 0:  # 检查距离是否为零
                avoid_vector[0] += (dx / dist) * constants.PREY_EVASION_FACTOR
                avoid_vector[1] += (dy / dist) * constants.PREY_EVASION_FACTOR

            # 定期回头观察
            self.turn_counter += 1
            if self.turn_counter >= constants.PREY_TURN_INTERVAL:
                self.turn_counter = 0  # 重置计时器
                # 模拟回头观察：调整方向
                avoid_vector[0] += random.uniform(-0.5, 0.5)
                avoid_vector[1] += random.uniform(-0.5, 0.5)

        # 靠近食物
        if observed_food:
            dx = observed_food.rect.x - self.rect.x
            dy = observed_food.rect.y - self.rect.y
            dist = self.distance_to(observed_food)
            if dist > 0:  # 检查距离是否为零
                move_vector[0] += dx / dist
                move_vector[1] += dy / dist

        # 避免障碍物
        if observed_obstacle:
            dx = self.rect.x - observed_obstacle.rect.x
            dy = self.rect.y - observed_obstacle.rect.y
            dist = self.distance_to(observed_obstacle)
            if dist > 0:  # 检查距离是否为零
                avoid_vector[0] += dx / dist
                avoid_vector[1] += dy / dist

        # 利用听觉信息
        for sound_intensity, sound_direction in heard_sounds:
            move_vector[0] += sound_intensity * math.cos(sound_direction)
            move_vector[1] += sound_intensity * math.sin(sound_direction)

        # 随机移动
        if not observed_predator and not observed_food:
            if random.random() < constants.PREY_RANDOM_MOVE_CHANCE:
                angle = random.uniform(-math.pi, math.pi)
                move_vector[0] += math.cos(angle) * constants.PREY_RANDOM_MOVE_SPEED
                move_vector[1] += math.sin(angle) * constants.PREY_RANDOM_MOVE_SPEED

        # 将避让捕食者和靠近食物的向量相结合
        final_vector = [
            move_vector[0] + avoid_vector[0],
            move_vector[1] + avoid_vector[1]
        ]

        return final_vector

    def eat_food(self, foods):
        for food in foods:
            if self.rect.colliderect(food.rect):
                self.health += constants.FOOD_HEALTH_GAIN
                if self.health > self.max_health:
                    self.health = self.max_health
                foods.remove(food)  # 从foods列表中移除被吃掉的食物
                return


    def crossbreed(self, other):
        child_x = (self.rect.x + other.rect.x) // 2
        child_y = (self.rect.y + other.rect.y) // 2
        child_size = constants.BLOCK_SIZE
        child = Prey(child_x, child_y, child_size)
        return child

    def mutate(self):
        self.velocity[0] = random.choice([-1, 1])
        self.velocity[1] = random.choice([-1, 1])

    def update_health(self):
        # 基础的健康值减少
        health_decay = self.health_decay

        # 根据速度变化计算加速度
        accel_x = self.velocity[0] - self.previous_velocity[0]
        accel_y = self.velocity[1] - self.previous_velocity[1]
        acceleration = math.sqrt(accel_x ** 2 + accel_y ** 2)
        
        # 根据加速度计算额外的健康值减少
        health_decay += acceleration * constants.PREY_ACCELERATION_HEALTH_DECAY_FACTOR

        self.health -= health_decay

        if self.health <= 0:
            self.health = 0
        elif self.health > self.max_health:
            self.health = self.max_health


# File: /home/qrbao/Downloads/code/code/coderesearch1/simulator.py
# simulator.py
import random
import pygame
from predator import Predator
from prey import Prey
from food import Food
from obstacle import Obstacle
import constants

class Simulator:
    def __init__(self, screen_width, screen_height):
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.predators = []
        self.prey = []
        self.foods = []
        self.obstacles = []
        self.selected_agent = None
        self.dead_predator_count = 0  # 新增变量记录死亡的捕食者数量
        self.food_generation_timer = 0  # 初始化食物生成计时器
        self.iteration_count = 0

    def initialize(self):
        self.initialize_obstacles()
        self.initialize_agents()
        self.initialize_food()
        self.food_generation_timer = 0  # 重置计时器

    def initialize_obstacles(self):
        self.obstacles = []
        num_obstacles = random.randint(5, 10)
        for _ in range(num_obstacles):
            while True:
                width = random.randint(50, 200)
                height = random.randint(50, 200)
                x = random.randint(constants.CONTROL_PANEL_WIDTH, self.screen_width - width)
                y = random.randint(0, self.screen_height - height)
                new_obstacle = Obstacle(x, y, width, height)

                if not any(new_obstacle.rect.colliderect(obs.rect) for obs in self.obstacles):
                    self.obstacles.append(new_obstacle)
                    break

    def initialize_agents(self):
        self.predators = []
        self.prey = []

        for _ in range(constants.NUM_PREDATORS):
            self.generate_predator()

        for _ in range(constants.NUM_PREY):
            self.generate_prey()

    def initialize_food(self):
        self.foods = []

        for _ in range(constants.NUM_FOOD):
            self.generate_food()

    def generate_prey(self):
        while True:
            x = random.randint(constants.CONTROL_PANEL_WIDTH, self.screen_width - constants.BLOCK_SIZE)
            y = random.randint(0, self.screen_height - constants.BLOCK_SIZE)
            new_prey = Prey(x, y, constants.BLOCK_SIZE)
            if not any(new_prey.rect.colliderect(obs.rect) for obs in self.obstacles):
                self.prey.append(new_prey)
                break

    def generate_predator(self):
        while True:
            x = random.randint(constants.CONTROL_PANEL_WIDTH, self.screen_width - constants.BLOCK_SIZE)
            y = random.randint(0, self.screen_height - constants.BLOCK_SIZE)
            new_predator = Predator(x, y, constants.BLOCK_SIZE)
            if not any(new_predator.rect.colliderect(obs.rect) for obs in self.obstacles):
                self.predators.append(new_predator)
                break

    def generate_food(self):
        while True:
            x = random.randint(constants.CENTER_AREA_X_START, constants.CENTER_AREA_X_START + constants.CENTER_AREA_WIDTH - constants.FOOD_SIZE)
            y = random.randint(constants.CENTER_AREA_Y_START, constants.CENTER_AREA_Y_START + constants.CENTER_AREA_HEIGHT - constants.FOOD_SIZE)
            new_food = Food(x, y, constants.FOOD_SIZE)
            if not any(new_food.rect.colliderect(obs.rect) for obs in self.obstacles):
                self.foods.append(new_food)
                break

    def breedPrey(self, prey):
        if prey.iteration_counter < constants.PREY_REPRODUCTION_ITERATION_THRESHOLD:
            return
        if prey.health < constants.PREY_MIN_HEALTH_FOR_REPRODUCTION:
            return
        if random.random() > constants.PREY_REPRODUCTION_PROBABILITY:
            return

        other_prey = random.choice(self.prey)
        if other_prey.health >= constants.PREY_MIN_HEALTH_FOR_REPRODUCTION:
            child = prey.crossbreed(other_prey)
            if random.random() < constants.MUTATION_CHANCE:
                child.mutate()
            self.ensure_no_collision(child)
            self.prey.append(child)

    def breedPredator(self, predator):
        if predator.iteration_counter < constants.PREDATOR_REPRODUCTION_ITERATION_THRESHOLD:
            return
        if predator.health < constants.PREDATOR_MIN_HEALTH_FOR_REPRODUCTION:
            return
        if random.random() > constants.PREDATOR_REPRODUCTION_PROBABILITY:
            return

        other_predator = random.choice(self.predators)
        if other_predator.health >= constants.PREDATOR_MIN_HEALTH_FOR_REPRODUCTION:
            child = predator.crossbreed(other_predator)
            if random.random() < constants.MUTATION_CHANCE:
                child.mutate()
            self.ensure_no_collision(child)
            self.predators.append(child)

    def applyGeneticAlgorithm(self):
        new_prey_born = 0
        new_predator_born = 0

        for prey in self.prey:
            initial_prey_count = len(self.prey)
            self.breedPrey(prey)
            if len(self.prey) > initial_prey_count:
                new_prey_born += 0

        for predator in self.predators:
            initial_predator_count = len(self.predators)
            self.breedPredator(predator)
            if len(self.predators) > initial_predator_count:
                new_predator_born += 1

        return new_prey_born, new_predator_born

    def generate_agent(self):
        self.applyGeneticAlgorithm()

    def ensure_no_collision(self, agent):
        while any(agent.rect.colliderect(obs.rect) for obs in self.obstacles):
            agent.rect.x = random.randint(constants.CONTROL_PANEL_WIDTH, self.screen_width - agent.rect.width)
            agent.rect.y = random.randint(0, self.screen_height - agent.rect.height)

    def add_food(self):
        self.iteration_count += 1
        if self.iteration_count % constants.FOOD_GENERATION_INTERVAL == 0:
            self.generate_random_food()
            self.generate_food_near_existing()

    def generate_random_food(self):
        num_random_foods = int(constants.MAX_FOOD_COUNT * constants.RANDOM_FOOD_PROPORTION)
        new_foods = []
        while len(new_foods) < num_random_foods:
            x = random.randint(constants.CENTER_AREA_X_START,constants.CENTER_AREA_X_START+constants.CENTER_AREA_WIDTH - constants.FOOD_SIZE)
            y = random.randint(constants.CENTER_AREA_Y_START, constants.CENTER_AREA_Y_START+constants.CENTER_AREA_HEIGHT - constants.FOOD_SIZE)
            new_food = Food(x, y, constants.FOOD_SIZE)
            if not any(new_food.rect.colliderect(obs.rect) for obs in self.obstacles) and \
            not any(new_food.rect.colliderect(f.rect) for f in self.foods):
                new_foods.append(new_food)
        self.foods.extend(new_foods)
        
    def generate_food_near_existing(self):
        directions = [(constants.FOOD_SPAWN_DISTANCE, 0), (-constants.FOOD_SPAWN_DISTANCE, 0),
                    (0, constants.FOOD_SPAWN_DISTANCE), (0, -constants.FOOD_SPAWN_DISTANCE)]
        
        if len(self.foods) >= constants.MAX_FOOD_COUNT:
            return

        new_foods = []
        for food in self.foods:
            for dx, dy in directions:
                x = food.rect.x + dx
                y = food.rect.y + dy
                if constants.CENTER_AREA_X_START <= x <= constants.CENTER_AREA_X_START + constants.CENTER_AREA_WIDTH - constants.FOOD_SIZE and \
                constants.CENTER_AREA_Y_START <= y <= constants.CENTER_AREA_Y_START + constants.CENTER_AREA_HEIGHT - constants.FOOD_SIZE:
                    new_food = Food(x, y, constants.FOOD_SIZE)
                    if not any(new_food.rect.colliderect(obs.rect) for obs in self.obstacles) and \
                    not any(new_food.rect.colliderect(f.rect) for f in self.foods):
                        new_foods.append(new_food)
                        if len(new_foods) + len(self.foods) >= constants.MAX_FOOD_COUNT:
                            break
            if len(new_foods) + len(self.foods) >= constants.MAX_FOOD_COUNT:
                break

        self.foods.extend(new_foods)

    def check_events(self):
        pass

    def remove_dead(self):
        self.predators = [p for p in self.predators if p.health > 0]
        self.prey = [p for p in self.prey if p.health > 0]

    def move_models(self):
        for predator in self.predators:
            predator.set_prey_list(self.prey)
            predator.env_predators = self.predators
            predator.env_prey = self.prey
            predator.env_food = self.foods
            predator.env_obstacles = self.obstacles
            self.move_predator(predator)
            predator.increment_iteration()  # 增加迭代计数器

        for prey in self.prey:
            prey.env_predators = self.predators
            prey.env_prey = self.prey
            prey.env_food = self.foods
            prey.env_obstacles = self.obstacles
            self.move_prey(prey)
            prey.increment_iteration()  # 增加迭代计数器

    def move_prey(self, prey):
        prey.move(constants.CONTROL_PANEL_WIDTH, self.screen_width, self.screen_height, self.obstacles)

    def move_predator(self, predator):
        predator.move(constants.CONTROL_PANEL_WIDTH, self.screen_width, self.screen_height, self.obstacles)

    def draw_models(self, screen):
        for obstacle in self.obstacles:
            obstacle.draw(screen)
        for predator in self.predators:
            predator.draw(screen)
        for prey_item in self.prey:
            prey_item.draw(screen)
        for food_item in self.foods:
            food_item.draw(screen)

        if self.selected_agent:
            agent_info = (
                f"{self.selected_agent.__class__.__name__}: "
                f"Position ({self.selected_agent.rect.x}, {self.selected_agent.rect.y}), "
                f"Velocity ({self.selected_agent.velocity[0]}, {self.selected_agent.velocity[1]}), "
                f"Health ({self.selected_agent.health})"
            )
            info_surface = pygame.font.Font(None, 24).render(agent_info, True, (255, 255, 255))
            screen.blit(info_surface, (50, self.screen_height - 100))

    def update_health(self):
        for predator in self.predators:
            predator.update_health()
        for prey_item in self.prey:
            prey_item.update_health()

    def prey_hunt(self):
        for prey_item in self.prey:
            prey_item.eat_food(self.foods)

    def predator_hunt(self):
        for predator in self.predators:
            predator.hunt_prey(self.prey)
            
    def remove_food(self, food):
        if food in self.foods:
            self.foods.remove(food)
                
    def decrease_health(self):
        self.update_health()
        self.remove_dead()

    def get_agent_info(self, pos):
        for agent in self.predators + self.prey:
            if agent.rect.collidepoint(pos):
                return agent
        return None

    def spawn_food(self, count):
        for _ in range(count):
            self.generate_food()



# File: /home/qrbao/Downloads/code/code/coderesearch1/obstacle.py
import pygame

class Obstacle:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)
        self.color = (100, 100, 100)  # 灰色

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect)


# File: /home/qrbao/Downloads/code/code/coderesearch1/food.py
import pygame
import constants

class Food:
    def __init__(self, x, y, size):
        self.rect = pygame.Rect(x, y, size, size)
        self.color = constants.FOOD_COLOR

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect)


# File: /home/qrbao/Downloads/code/code/coderesearch1/tools/code2txt.py
import os

def collect_py_files_to_txt(parent_dir, output_file):
    with open(output_file, 'w') as outfile:
        for root, dirs, files in os.walk(parent_dir):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    with open(file_path, 'r') as infile:
                        outfile.write(f'# File: {file_path}\n')
                        outfile.write(infile.read())
                        outfile.write('\n\n')

if __name__ == "__main__":
    parent_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))  # 获取上一层文件夹路径
    output_file = os.path.join(os.getcwd(), 'all_python_files1.txt')  # 输出文件路径

    collect_py_files_to_txt(parent_dir, output_file)
    print(f'所有的 .py 文件已整合到 {output_file}')



